generator client {
  provider = "prisma-client"
  output   = "../app/generated/prisma"
}

datasource db {
  provider = "postgresql"
}

model Page {
  id        String   @id @default(cuid())
  slug      String   @unique
  title     String
  content   Json
  visible   Boolean  @default(true)
  createdAt DateTime @default(now())
  updatedAt DateTime @updatedAt
}

enum UserRole {
  USER
  ADMIN
}

model User {
  id        String          @id @default(cuid())
  email     String          @unique
  password  String
  role      UserRole        @default(USER)
  createdAt DateTime        @default(now())
  updatedAt DateTime        @updatedAt
  reviews   ProductReview[]
  orders    Order[]
}

model Product {
  id          String   @id @default(cuid())
  name        String
  slug        String   @unique
  description String?
  active      Boolean  @default(true)
  createdAt   DateTime @default(now())
  updatedAt   DateTime @updatedAt

  images      ProductImage[]
  variants    Variant[]
  collections ProductCollection[]
  reviews     ProductReview[]

  @@index([active])
}

model ProductImage {
  id        String  @id @default(cuid())
  productId String
  url       String
  alt       String?

  createdAt DateTime @default(now())

  product Product @relation(fields: [productId], references: [id], onDelete: Cascade)

  @@index([productId])
}

model Variant {
  id         String  @id @default(cuid())
  productId  String
  name       String
  priceCents Int
  sku        String? @unique
  stock      Int     @default(0)

  createdAt DateTime @default(now())
  updatedAt DateTime @updatedAt

  product                Product                 @relation(fields: [productId], references: [id], onDelete: Cascade)
  cartItems              CartItem[]
  orderItems             OrderItem[]
  variantAttributeValues VariantAttributeValue[]

  @@index([productId])
  @@index([priceCents])
}

model Attribute {
  id        String   @id @default(cuid()) // maybe would be better to use autoincrement here
  name      String
  createdAt DateTime @default(now())
  updatedAt DateTime @updatedAt

  values AttributeValue[]

  @@index([name])
}

model AttributeValue {
  id                     String                  @id @default(cuid())
  value                  String
  attributeId            String
  createdAt              DateTime                @default(now())
  updatedAt              DateTime                @updatedAt
  attribute              Attribute               @relation(fields: [attributeId], references: [id], onDelete: Cascade)
  variantAttributeValues VariantAttributeValue[]

  @@unique([attributeId, value])
  @@index([attributeId])
  @@index([value])
}

model VariantAttributeValue {
  variantId        String
  attributeValueId String

  variant        Variant        @relation(fields: [variantId], references: [id], onDelete: Cascade)
  attributeValue AttributeValue @relation(fields: [attributeValueId], references: [id], onDelete: Cascade)

  @@id([variantId, attributeValueId])
  @@index([attributeValueId])
  @@index([variantId])
}

model Cart {
  id        String   @id // weâ€™ll set this ourselves (cookie id)
  createdAt DateTime @default(now())
  updatedAt DateTime @updatedAt

  items CartItem[]
}

model CartItem {
  id        String   @id @default(cuid())
  cartId    String
  variantId String
  quantity  Int      @default(1)
  createdAt DateTime @default(now())
  updatedAt DateTime @updatedAt

  cart    Cart    @relation(fields: [cartId], references: [id], onDelete: Cascade)
  variant Variant @relation(fields: [variantId], references: [id], onDelete: Restrict)

  @@unique([cartId, variantId])
  @@index([variantId])
}

enum OrderStatus {
  PENDING
  PAID
  CANCELED
  REFUNDED
}

model Order {
  id         String      @id @default(cuid())
  email      String
  totalCents Int
  status     OrderStatus @default(PENDING)

  userId String?
  user   User?   @relation(fields: [userId], references: [id], onDelete: Cascade)

  createdAt DateTime @default(now())
  updatedAt DateTime @updatedAt

  items OrderItem[]

  @@index([email])
  @@index([status])
  @@index([userId])
}

model OrderItem {
  id        String  @id @default(cuid())
  orderId   String
  variantId String? // optional so order history survives deleted variants

  title      String // snapshot: product + variant name at purchase time
  sku        String? // snapshot
  priceCents Int // snapshot
  quantity   Int

  createdAt DateTime @default(now())

  order   Order    @relation(fields: [orderId], references: [id], onDelete: Cascade)
  variant Variant? @relation(fields: [variantId], references: [id], onDelete: SetNull)

  @@index([orderId])
}

model Collection {
  id          String   @id @default(cuid())
  name        String
  slug        String   @unique
  description String?
  createdAt   DateTime @default(now())
  updatedAt   DateTime @updatedAt

  products ProductCollection[]

  @@index([slug])
}

model ProductCollection {
  productId    String
  collectionId String
  assignedAt   DateTime @default(now())

  product    Product    @relation(fields: [productId], references: [id], onDelete: Cascade)
  collection Collection @relation(fields: [collectionId], references: [id], onDelete: Cascade)

  @@id([productId, collectionId])
  @@index([collectionId])
  @@index([productId])
}

// Product reviews
model ProductReview {
  id        String   @id @default(cuid())
  rating    Int // 1-5 stars
  comment   String?
  productId String
  userId    String
  createdAt DateTime @default(now())
  updatedAt DateTime @updatedAt

  product Product @relation(fields: [productId], references: [id], onDelete: Cascade)
  user    User    @relation(fields: [userId], references: [id], onDelete: Cascade)

  @@index([productId])
  @@index([userId])
  @@index([rating])
}
